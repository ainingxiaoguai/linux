中断上下文、进程上下文（http://blog.csdn.net/jin13277480598/article/details/50947494）

在学习与操作系统相关的知识时候，我们经常遇到进程上下文、中断上下文，看似熟悉又感觉不是特别清晰。这里我们从如下几个方面进行描述。

1.上下文

1.1上下文一词的来源

上下文是从英文中context翻译过来的，指的是一种环境。

1.2上下文的理解

上下文我们看起来不怎么熟悉，但是我们可以看context的中文翻译，或者我们能更加的情形些。Context ：n 语境；上下文；背景；环境。如过我们对上下文这个词确实不习惯，可以把它理解成环境来讲。

1.3上下文在工程上面理解

在软件工程中，上下文是一种属性的有序序列，它们为驻留在环境内的对象定义环境。在对象的激活过程中创建上下文，对象被配置为要求某些自动服务，如同步、事务、实时激活、安全性等等。又比如计算机技术中，相对于进程而言，上下文就是进程执行时的环境。具体来说就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存信息等。

2.进程上下文

2.1 进程上下文的定义

所谓的“进程上下文”，就是一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈上的内容，当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行。
        简单来讲，当一个进程在执行时,CPU的所有寄存器中的值、进程的状态以及堆栈中的内容被称为该进程的上下文。

2.2进程上下文的组成

一个进程的上下文可以分为三个部分:用户级上下文、寄存器上下文以及系统级上下文。

用户级上下文: 正文、数据、用户堆栈以及共享存储区；

寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；

系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。

3.中断上下文

3.1中断上下文的定义

中断上下文，可以看作就是硬件传递过来的相关参数和内核需要保存的一些其他环境（主要是当前被中断的进程环境）。

    在LINUX中，当前进程上下文均保存在进程的任务数据结构中。在发生中断时,内核就在被中断进程的上下文中，在内核态下执行中断服务例程。但同时会保留所有需要用到的资源，以便中断服务结束时能恢复被中断进程的执行。

4.引入上下文的原因

4.1处理器的几种状态

         处理器是处于以下三种情况中的一种：

1、内核态，运行于进程上下文，内核代表进程运行于内核空间；

2、内核态，运行于中断上下文，内核代表硬件运行于内核空间；

3、用户态，运行于用户空间。

4.2为什么区分内核空间和用户空间

内核功能模块运行在内核空间，而应用程序运行在用户空间。现代的CPU都具有不同的操作模式，代表不同的级别，不同的级别具有不同的功能，在较低的级别中将禁止某些操作。

Linux系统设计时利用了这种硬件特性，使用了两个级别，最高级别和最低级别，内核运行在最高级别（内核态），这个级别可以进行所有操作，而应用程序运行在较低级别（用户态），在这个级别，处理器控制着对硬件的直接访问以及对内存的非授权访问。内核态和用户态有自己的内存映射，即自己的地址空间。



Linux系统只能通过系统调用和硬件中断完成从用户空间到内核空间的控制转移。

4.3引用上下文的原因

正是因为内核有了不同运行状态的划分，才用了上下文的概念。


通过系统调用，用户空间的应用程序就会进入内核空间，由内核代表该进程运行于内核空间，这就涉及到上下文的切换，用户空间和内核空间具有不同的地址映射，通用或专用的寄存器组，而用户空间的进程要传递很多变量、参数给内核，内核也要保存用户进程的一些寄存器、变量等，以便系统调用结束后回到用户空间继续执行，所谓的进程上下文，就是一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈中的内容，当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行。

硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理，中断上下文就可以理解为硬件传递过来的这些参数和内核需要保存的一些环境，主要是被中断的进程的环境。


引用LINUX内核完全注释中的一段话：

当一个进程在执行时,CPU的所有寄存器中的值、进程的状态以及堆栈中的内容被称为该进程的上下文。当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即保存当前进程的上下文，以便在再次执行该进程时，能够必得到切换时的状态执行下去。在LINUX中，当前进程上下文均保存在进程的任务数据结构中。在发生中断时,内核就在被中断进程的上下文中，在内核态下执行中断服务例程。但同时会保留所有需要用到的资源，以便中继服务结束时能恢复被中断进程的执行。

5.两个上下文的区别

中断上下文：当内核执行一个中断处理程序时，内核处于中断上下文中。中断上下文和进程无关。因为没有后备进程，所以中断上下文不可以睡眠，不能在里面进行有可能使它睡眠的操作。中断上下文会一直运行至结束，不会被抢占。

进程上下文：进程上下文是一种内核所处的操作模式，此时内核代表进程执行-------例如，执行系统调用或运行内核线程。在线程上下文，可以通过current宏关联当前进程。因为进程是以进程上下文的形式连接到内核中断，因此，进程上下文可以睡眠，也可以调度程序。运行于进程上下文的内核代码是可抢占的。


进程上下文主要是异常处理程序和内核线程。内核之所以进入进程上下文是因为进程自身的一些工作需要在内核中做。例如，系统调用是为当前进程服务的，异常通常是处理进程导致的错误状态等。所以在进程上下文中引用current是有意义的。

 

内核进入中断上下文是因为中断信号而导致的中断处理或软中断。而中断信号的发生是随机的，中断处理程序及软中断并不能事先预测发生中断时当前运行的是哪个进程，所以在中断上下文中引用current是可以的，但没有意义。事实上，对于A进程希望等待的中断信号，可能在B进程执行期间发生。例如，A进程启动写磁盘操作，A进程睡眠后B进程在运行，当磁盘写完后磁盘中断信号打断的是B进程，在中断处理时会唤醒A进程。

内核可以处于两种上下文：进程上下文和中断上下文。在系统调用之后，用户应用程序进入内核空间，此后内核空间针对用户空间相应进程的代表就运行于进程上下文。异步发生的中断会引发中断处理程序被调用，中断处理程序就运行于中断上下文。中断上下文和进程上下文不可能同时发生。

 

6.中断上下文的注意点

内核会限制中断上下文的工作，不允许其执行如下操作：

(1) 进入睡眠状态或主动放弃CPU；

由于中断上下文不属于任何进程，它与current没有任何关系（尽管此时current指向被中断的进程），所以中断上下文一旦睡眠或者放弃CPU，将无法被唤醒。所以也叫原子上下文（atomic context）。

(2) 占用互斥体；

为了保护中断句柄临界区资源，不能使用mutexes。如果获得不到信号量，代码就会睡眠，会产生和上面相同的情况，如果必须使用锁，则使用spinlock。

(3) 执行耗时的任务；

中断处理应该尽可能快，因为内核要响应大量服务和请求，中断上下文占用CPU时间太长会严重影响系统功能。在中断处理例程中执行耗时任务时，应该交由中断处理例程底半部来处理。

(4) 访问用户空间虚拟内存；

因为中断上下文是和特定进程无关的，它是内核代表硬件运行在内核空间，所以在中断上下文无法访问用户空间的虚拟地址

(5) 中断处理例程不应该设置成reentrant（可被并行或递归调用的例程)；

因为中断发生时，preempt和irq都被disable，直到中断返回。所以中断上下文和进程上下文不一样，中断处理例程的不同实例，是不允许在SMP上并发运行的。

(6)中断处理例程可以被更高级别的IRQ中断。

如果想禁止这种中断，可以将中断处理例程定义成快速处理例程，相当于告诉CPU，该例程运行时，禁止本地CPU上所有中断请求。这直接导致的结果是，由于其他中断被延迟响应，系统性能下降。
